// Read digits from an image given as a set of pixels.
// Approach: breadth-first search to find digits (connectivitiy components), then compare the shapes to pre-created templates.
// Not fully functional because of a bug...
// https://www.codewars.com/kata/5ec9e176721b990029ebce83

#include <bits/stdc++.h>
using namespace std; 
using lli = long long int;
#define forup(i,i0,n) for(int i=i0; i<=(int)n; i++)
#define fordown(i,n,i0) for(int i=n; i>=(int)i0; i--)

vector <string> refer = {
"001111222222222222222222111000011111111111111111111111111110111111111111111111111111111111211111111111111111111111111111322222000000000000000000222222211111000000000000000000111111211111000000000000000000111111211111000000000000000000111111322222000000000000000000222222211111000000000000000000111111211111000000000000000000111111211111000000000000000000111111322222000000000000000000222222211111000000000000000000111111211111000000000000000000111111211111000000000000000000111111211111000000000000000000111111322222000000000000000000222222211111000000000000000000111111211111000000000000000000111111211111000000000000000000111111322222000000000000000000222222211111000000000000000000111111211111000000000000000000111111211111000000000000000000111111322222000000000000000000222222211111111111111111111111111111111111111111111111111111111111011111111111111111111111111110001111111111111111111111111000",
"122222222222222422000000000000322222222222222322000000000000222222222222222322000000000000012222222222222322000000000000000000000000222322000000000000000000000000222422000000000000000000000000222322000000000000000000000000222322000000000000000000000000222322000000000000000000000000222322000000000000000000000000222422000000000000000000000000222322000000000000000000000000222322000000000000000000000000222322000000000000000000000000222322000000000000000000000000222422000000000000000000000000222322000000011110000000000000222322000000222221000000000000222322000001222222000000000000222322000001222222000000000000222422000001222222000000000000222322000001222222000000000000222322000001222222000000000000222322000001222222000000000000222322000001222222000000000000222422000001222222112222222222222322222222222222322222222222222322222222222222222222222222222322222222222221012222222222222322222222222110",
"122222222222222322222222211000211111111111111211111111111110211111111111111211111111111110011111111111111211111111111111000000000000000000000000111111000000000000000000000001222222000000000000000000000000111111000000000000000000000000111111000000000000000000000000111111000000000000000000000000111111000000000000000000000001222222000000000000000000000000111111000000000000000000000001111111000111111111111211111111111111011111111111111211111111111110222222222222222322222222222200211111111111111211111111100000211111000000000000000000000000211110000000000000000000000000211110000000000000000000000000322221000000000000000000000000211110000000000000000000000000211110000000000000000000000000211110000000000000000000000000211110000000000000000000000000322221000000000000000000000000211111111111111211111111111110211111111111111211111111111111211111111111111211111111111111211111111111111211111111111110",
"112222222222222322222222211000211111111111111211111111111110211111111111111211111111111110011111111111111211111111111111000000000000000000000000111111000000000000000000000001222222000000000000000000000000111111000000000000000000000000111111000000000000000000000000111111000000000000000000000000111111000000000000000000000001222222000000000000000000000000111111000000000000000000000001111110000000011111111211111111111110000000111111111211111111111100000000222222222322222222222210000000001111111111111111111110000000000000000000000001111111000000000000000000000000111111000000000000000000000000111111000000000000000000000001222222000000000000000000000000111111000000000000000000000000111111000000000000000000000000111111000000000000000000000000111111000000000000000000000001222222011111111111111211111111111111111111111111111211111111111110111111111111111211111111111110011111111111111211111111111000",
"123321000000000000000000000000222221100000000000000000000000222221200000000000000000000000222221200000000000000110100000222221200000000000001221220000333331300000000000013331331000222221200000000000012221221000222221200000000000012221221000222221200000000000012221221000222221200000000000012221221000333331300000000000013331331000222221200000000000012221221000222221200000000000012221221000222221200000000000012221221000222221200000000000012221221000333331300000000000013331331000222221222221222221222221222110222221222221222221222221222220222221222221222221222221222220222221222221222221222221222210000000000000000000013331331000000000000000000000012221221000000000000000000000012221221000000000000000000000012221221000000000000000000000012221221000000000000000000000013331331000000000000000000000012221221000000000000000000000012221221000000000000000000000002221220000000000000000000000000121110000",
"000000222222222322222222222210000000111111111211111111111110000000111111111211111111111110000000111111111211111111111100000000111111000000000000000000000001222221000000000000000000000000111110000000000000000000000000111110000000000000000000000000111110000000000000000000000000111110000000000000000000000001222221000000000000000000000000111110000000000000000000000000111111000000000000000000000000111111111211111111110000000000111111111211111111111100000001222222222322222222222220000000111111111211111111111111000000000000000000000001111111000000000000000000000001111111000000000000000000000001111111000000000000000000000002222222000000000000000000000001111111000000000000000000000001111111000000000000000000000001111111000000000000000000000001111111322222110000000000000002222222211111111111111211111111111110111111111111111211111111111110000111111111111211111111111100000000111111111211111111110000",
"112222210000000000000000000000211111110000000000000000000000211111110000000000000000000000211111100000000000000000000000211111000000000000000000000000322221000000000000000000000000211110000000000000000000000000211110000000000000000000000000211110000000000000000000000000211110000000000000000000000000322221000000000000000000000000211110000000000000000000000000211110000000000000000000000000211110000000000000000000000000211110000000000000000000000000322221000000000000000000000000211111111111111211111111111100211111111111111211111111111110211111111111111211111111111111211111111111111211111111111111322221000000000000000002222222211110000000000000000001111111211110000000000000000001111111211110000000000000000001111111211110000000000000000001111111322221000000000000000002222222211111111111111211111111111111211111111111111211111111111111211111111111111211111111111111011111111111111211111111111110",
"223333333333333333333333333333322222222222222222222222222222422222222222222222222222222222422222222222222222222222222222222221000000000000000000222222001000000000000000000000333333000000000000000000000000222222000000000000000000000000222222000000000000000000000000222222000000000000000000000000222222000000000000000000000000333333000000000000000000000012222222000000000000000000001222222222000000000000000000022222222210000000000000000002222222221000000000000000000233333333200000000000000000022222222210000000000000000000222222222000000000000000000000222222200000000000000000000000222222000000000000000000000000333333000000000000000000000000222222000000000000000000000000222222000000000000000000000000222222000000000000000000000000222222000000000000000000000000333333000000000000000000000000222222000000000000000000000000222222000000000000000000000000222222000000000000000000000000112210000000000000",
"000000012222222322222110000000000000111111111211111111000000000000111111111211111111000000000000111111111211111111000000000000111111000000111111000000000001222222000000222222000000000000111111000000111111000000000000111111000000111111000000000000111111000000111111000000000000111111000000111111000000000001222222000000222222000000000000111111000000111111000000000000111111000000111111000000000111111111111211111111111000011111111111111211111111111100222222222222222322222222222221211111111111111211111111111111211111000000000000000000111111211111000000000000000000111111211111000000000000000000111111322222000000000000000000222222211111000000000000000000111111211111000000000000000000111111211111000000000000000000111111211111000000000000000000111111322222000000000000000000222222211111111111111211111111111111111111111111111211111111111110011111111111111211111111111100000111111111111211111111111000",
"011222222222222322222222222110211111111111111211111111111111211111111111111211111111111111211111111111111211111111111111322222000000000000000000222222211111000000000000000000111111211111000000000000000000111111211111000000000000000000111111322222000000000000000000222222211111000000000000000000111111211111111111111211111111111111211111111111111211111111111111222222222222222322222222222222000111111111111111111111111111000000000000000000000000111111000000000000000000000000111111000000000000000000000000111111000000000000000000000001222222000000000000000000000000111111000000000000000000000000111111000000000000000000000000111111000000000000000000000001222222000000000000000000000000111111000000000000000000000000111111000000000000000000000000111111000000000000000000000001222222000000000000000000000011111111000000000000000000000111111111000000000000000000000111111111000000000000000000000011111110"
};

vector <vector <int> > neigh (vector <int> v, int n, int m ) {
	vector <vector <int> > ngh; 

    if (v[0]-1>=0) ngh.push_back({v[0]-1,v[1]});
    if (v[0]+1<n) ngh.push_back({v[0]+1,v[1]});
    if (v[1]-1>=0) ngh.push_back({v[0],v[1]-1});
    if (v[1]+1<m) ngh.push_back({v[0],v[1]+1});

    if (v[0]-1>=0 and v[1]-1>=0) ngh.push_back({v[0]-1,v[1]-1});
    if (v[0]+1<n and v[1]+1<m) ngh.push_back({v[0]+1,v[1]+1});
    if (v[0]-1>=0 and v[1]+1<m) ngh.push_back({v[0]-1,v[1]+1});
    if (v[0]+1<n and v[1]-1>=0) ngh.push_back({v[0]+1,v[1]-1});

    return ngh;
}

vector <vector <int> > bfs(vector <vector <int> > grid, vector <vector <bool> > &visit, vector <int> s, int maxColor, int n, int m) {
    
    deque <vector <int> > q(1, s);
    visit[s[0]][s[1]] = true;
    vector <vector <int> > frag; 
    while(!q.empty()) {
        auto v = q[0];
        q.pop_front();
        frag.push_back(v); 
        for (auto u : neigh(v, n, m)) {
            if (!visit[u[0]][u[1]] and grid[u[0]][u[1]] <= maxColor) {
                visit[u[0]][u[1]] = true;
                q.push_back(u); 
            }
        }
    }
    return frag; 
} 

vector <float> center(vector<vector <int> > frag) {
    float x = 0;
    float y = 0;
    int n = frag.size(); 
    forup(i,0,n-1) {
        x += (float)frag[i][0];
        y += (float)frag[i][1]; 
    } 
    return {x/(float)n, y/(float)n}; 
}

float dist(vector <float> a, vector <float> b) {
    return sqrt(pow(a[0]-b[0],2.0)+pow(a[1]-b[1],2.0));
}

bool orderOfFragments(vector <vector <int> > a, vector <vector <int> > b) {
    return center(a)[1] < center(b)[1];
}


string digit(vector <vector <int> > frag) {
    int n = frag.size();
    auto cent = center(frag);
    vector <vector <float> > fr(n, vector <float> (2));

    vector <vector <float> > bord(2, vector <float> (2));
    bord[0][0] = 1e10;
    bord[0][1] = 0;
    bord[1][0] = 1e10;
    bord[1][1] = 0;

    forup(i,0,n-1) {
        forup(j,0,1) {
            bord[j][0] = (bord[j][0]<frag[i][j]) ? bord[j][0] : frag[i][j];
            bord[j][1] = (bord[j][1]>frag[i][j]) ? bord[j][1] : frag[i][j];
        }
    }

    int r = 30;
    vector <vector <int> > dat(r, vector <int> (r, 0));

    forup(i,0,n-1) {
        float x = (float)r*((float)frag[i][0] - bord[0][0])/(bord[0][1]-bord[0][0]+1);
        float y = (float)r*((float)frag[i][1] - bord[1][0])/(bord[1][1]-bord[1][0]+1);
        dat[(int)x][(int)y]++;
    }

    forup(i,0,r-1) {
        forup(j,0,r-1) {
            dat[i][j] = dat[i][j]*r*r/n;
            if (dat[i][j]>0) cout << dat[i][j];
            else cout << " ";
        }
        cout << endl;
    }

    string ans = "";
    float minDev = 1e8; 
    forup(i,0,9) {
        float dev = 0;
        forup(j,0,r*r-1) {
            dev += pow(dat[j/r][j%r] - (int)refer[i][j]+48, 2.0);
        }
        if (dev < minDev) {
            minDev = dev;
            ans = to_string(i); 
        }
        cout << i << " " << dev << endl;
    }
    cout << "Digit " << ans << endl;
    return ans; 
    
}

string ocr(const Image &image) {

    int n = (int)image.height;
    int m = (int)image.width;
    
    vector <vector <int> > grid(n, vector <int> (m));
    
    lli averageColor = 0;
    forup(k,0,image.pixels.size()-1) {
      grid[k/m][k%m] = (int)image.pixels[k];
      averageColor += (int)image.pixels[k];
    }
    
    averageColor = averageColor/(int)image.pixels.size();
  
    int maxColor = 100; 

    vector <vector <vector <int> > > frags; 
    vector <vector <bool> > visit(n, vector <bool> (m, false));

    forup(i,0,n-1) {
        forup(j,0,m-1) {
            if (!visit[i][j] and grid[i][j] < maxColor) {
                cout << "new frag" << endl;
                auto frag = bfs(grid, visit, {i,j}, maxColor, n, m);
                cout << frag.size() << endl;
                if (frag.size()>1) frags.push_back(frag);
            }     
        }
    }

    sort(frags.begin(), frags.end(), orderOfFragments); 

    cout << "Total fragments: " << frags.size() << endl;
    
    string ans = "";
    forup(i,0,frags.size()-1) {
        cout << "Fragment " << i << endl;
        ans+=digit(frags[i]);
        cout << "-------\n";
    }

    return ans;
}

